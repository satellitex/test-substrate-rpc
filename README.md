# How to test

**Now Substrate Test Substrate Version**

Substrate tag = 'v1.0.0rc2'

## Your Default Substrate Node
Please see how to install substrate [here](https://substrate.dev/docs/en/quickstart/installing-substrate#manual-build).
```bash
$ substrate --version
version 1.0.0-6506c2d1c-x86_64-macos
$ substrate --dev
```

## Test Get Metadata
```bash
$ cargo build
$ ./target/debug/test-substrate-rpc
Get Hash: Ok(Some(0xcc16a8ae865a52b0c36d373fa185e515abcd8d7e71cc4d9310a4a24021bb9837))
Get Metadata: Ok(RuntimeMetadataPrefixed(1635018093, V4(RuntimeMetadataV4 { modules: [ModuleMetadata { name: "system", prefix: "System", storage: Some([StorageFunctionMetadata { name: "AccountNonce", modifier: Default, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "T::Index", is_linked: false }, default: [0, 0, 0, 0, 0, 0, 0, 0], documentation: [" Extrinsics nonce for accounts."] }, StorageFunctionMetadata { name: "ExtrinsicCount", modifier: Optional, ty: Plain("u32"), default: [0], documentation: [" Total extrinsics count for the current block."] }, StorageFunctionMetadata { name: "AllExtrinsicsLen", modifier: Optional, ty: Plain("u32"), default: [0], documentation: [" Total length in bytes for all extrinsics put together, for the current block."] }, StorageFunctionMetadata { name: "BlockHash", modifier: Default, ty: Map { hasher: Blake2_256, key: "T::BlockNumber", value: "T::Hash", is_linked: false }, default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" Map of block numbers to block hashes."] }, StorageFunctionMetadata { name: "ExtrinsicData", modifier: Default, ty: Map { hasher: Blake2_256, key: "u32", value: "Vec<u8>", is_linked: false }, default: [0], documentation: [" Extrinsics data for the current block (maps extrinsic\'s index to its data)."] }, StorageFunctionMetadata { name: "RandomSeed", modifier: Default, ty: Plain("T::Hash"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" Random seed of the current block."] }, StorageFunctionMetadata { name: "Number", modifier: Default, ty: Plain("T::BlockNumber"), default: [0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The current block number being processed. Set by `execute_block`."] }, StorageFunctionMetadata { name: "ParentHash", modifier: Default, ty: Plain("T::Hash"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" Hash of the previous block."] }, StorageFunctionMetadata { name: "ExtrinsicsRoot", modifier: Default, ty: Plain("T::Hash"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" Extrinsics root of the current block, also part of the block header."] }, StorageFunctionMetadata { name: "Digest", modifier: Default, ty: Plain("T::Digest"), default: [0], documentation: [" Digest of the current block, also part of the block header."] }, StorageFunctionMetadata { name: "Events", modifier: Default, ty: Plain("Vec<EventRecord<T::Event>>"), default: [0], documentation: [" Events deposited for the current block."] }]), calls: None, event: Some([EventMetadata { name: "ExtrinsicSuccess", arguments: [], documentation: [" An extrinsic completed successfully."] }, EventMetadata { name: "ExtrinsicFailed", arguments: [], documentation: [" An extrinsic failed."] }]) }, ModuleMetadata { name: "aura", prefix: "", storage: None, calls: None, event: None }, ModuleMetadata { name: "timestamp", prefix: "Timestamp", storage: Some([StorageFunctionMetadata { name: "Now", modifier: Default, ty: Plain("T::Moment"), default: [0, 0, 0, 0, 0, 0, 0, 0], documentation: [" Current time for the current block."] }, StorageFunctionMetadata { name: "BlockPeriod", modifier: Optional, ty: Plain("T::Moment"), default: [0], documentation: [" Old storage item provided for compatibility. Remove after all networks upgraded."] }, StorageFunctionMetadata { name: "MinimumPeriod", modifier: Default, ty: Plain("T::Moment"), default: [3, 0, 0, 0, 0, 0, 0, 0], documentation: [" The minimum period between blocks. Beware that this is different to the *expected* period", " that the block production apparatus provides. Your chosen consensus system will generally", " work with this to determine a sensible block time. e.g. For Aura, it will be double this", " period on default settings."] }, StorageFunctionMetadata { name: "DidUpdate", modifier: Default, ty: Plain("bool"), default: [0], documentation: [" Did the timestamp get updated in this block?"] }]), calls: Some([FunctionMetadata { name: "set", arguments: [FunctionArgumentMetadata { name: "now", ty: "Compact<T::Moment>" }], documentation: [" Set the current time.", "", " This call should be invoked exactly once per block. It will panic at the finalization phase,", " if this call hasn\'t been invoked by that time.", "", " The timestamp should be greater than the previous one by the amount specified by `minimum_period`.", "", " The dispatch origin for this call must be `Inherent`."] }]), event: None }, ModuleMetadata { name: "consensus", prefix: "Consensus", storage: Some([StorageFunctionMetadata { name: "OriginalAuthorities", modifier: Optional, ty: Plain("Vec<T::SessionKey>"), default: [0], documentation: [] }]), calls: Some([FunctionMetadata { name: "report_misbehavior", arguments: [FunctionArgumentMetadata { name: "_report", ty: "Vec<u8>" }], documentation: [" Report some misbehavior."] }, FunctionMetadata { name: "note_offline", arguments: [FunctionArgumentMetadata { name: "offline", ty: "<T::InherentOfflineReport as InherentOfflineReport>::Inherent" }], documentation: [" Note that the previous block\'s validator missed its opportunity to propose a block."] }, FunctionMetadata { name: "remark", arguments: [FunctionArgumentMetadata { name: "_remark", ty: "Vec<u8>" }], documentation: [" Make some on-chain remark."] }, FunctionMetadata { name: "set_heap_pages", arguments: [FunctionArgumentMetadata { name: "pages", ty: "u64" }], documentation: [" Set the number of pages in the WebAssembly environment\'s heap."] }, FunctionMetadata { name: "set_code", arguments: [FunctionArgumentMetadata { name: "new", ty: "Vec<u8>" }], documentation: [" Set the new code."] }, FunctionMetadata { name: "set_storage", arguments: [FunctionArgumentMetadata { name: "items", ty: "Vec<KeyValue>" }], documentation: [" Set some items of storage."] }, FunctionMetadata { name: "kill_storage", arguments: [FunctionArgumentMetadata { name: "keys", ty: "Vec<Key>" }], documentation: [" Kill some items from storage."] }]), event: None }, ModuleMetadata { name: "indices", prefix: "Indices", storage: Some([StorageFunctionMetadata { name: "NextEnumSet", modifier: Default, ty: Plain("T::AccountIndex"), default: [0, 0, 0, 0], documentation: [" The next free enumeration set."] }, StorageFunctionMetadata { name: "EnumSet", modifier: Default, ty: Map { hasher: Blake2_256, key: "T::AccountIndex", value: "Vec<T::AccountId>", is_linked: false }, default: [0], documentation: [" The enumeration sets."] }]), calls: Some([]), event: Some([EventMetadata { name: "NewAccountIndex", arguments: ["AccountId", "AccountIndex"], documentation: [" A new account index was assigned.", "", " This event is not triggered when an existing index is reassigned", " to another `AccountId`."] }]) }, ModuleMetadata { name: "balances", prefix: "Balances", storage: Some([StorageFunctionMetadata { name: "TotalIssuance", modifier: Default, ty: Plain("T::Balance"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The total units issued in the system."] }, StorageFunctionMetadata { name: "ExistentialDeposit", modifier: Default, ty: Plain("T::Balance"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The minimum amount required to keep an account open."] }, StorageFunctionMetadata { name: "TransferFee", modifier: Default, ty: Plain("T::Balance"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The fee required to make a transfer."] }, StorageFunctionMetadata { name: "CreationFee", modifier: Default, ty: Plain("T::Balance"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The fee required to create an account."] }, StorageFunctionMetadata { name: "TransactionBaseFee", modifier: Default, ty: Plain("T::Balance"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The fee to be paid for making a transaction; the base."] }, StorageFunctionMetadata { name: "TransactionByteFee", modifier: Default, ty: Plain("T::Balance"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The fee to be paid for making a transaction; the per-byte portion."] }, StorageFunctionMetadata { name: "Vesting", modifier: Optional, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "VestingSchedule<T::Balance>", is_linked: false }, default: [0], documentation: [" Information regarding the vesting of a given account."] }, StorageFunctionMetadata { name: "FreeBalance", modifier: Default, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "T::Balance", is_linked: false }, default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The \'free\' balance of a given account.", "", " This is the only balance that matters in terms of most operations on tokens. It", " alone is used to determine the balance when in the contract execution environment. When this", " balance falls below the value of `ExistentialDeposit`, then the \'current account\' is", " deleted: specifically `FreeBalance`. Further, the `OnFreeBalanceZero` callback", " is invoked, giving a chance to external modules to clean up data associated with", " the deleted account.", "", " `system::AccountNonce` is also deleted if `ReservedBalance` is also zero (it also gets", " collapsed to zero if it ever becomes less than `ExistentialDeposit`."] }, StorageFunctionMetadata { name: "ReservedBalance", modifier: Default, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "T::Balance", is_linked: false }, default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The amount of the balance of a given account that is externally reserved; this can still get", " slashed, but gets slashed last of all.", "", " This balance is a \'reserve\' balance that other subsystems use in order to set aside tokens", " that are still \'owned\' by the account holder, but which are suspendable.", "", " When this balance falls below the value of `ExistentialDeposit`, then this \'reserve account\'", " is deleted: specifically, `ReservedBalance`.", "", " `system::AccountNonce` is also deleted if `FreeBalance` is also zero (it also gets", " collapsed to zero if it ever becomes less than `ExistentialDeposit`.)"] }, StorageFunctionMetadata { name: "Locks", modifier: Default, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "Vec<BalanceLock<T::Balance, T::BlockNumber>>", is_linked: false }, default: [0], documentation: [" Any liquidity locks on some account balances."] }]), calls: Some([FunctionMetadata { name: "transfer", arguments: [FunctionArgumentMetadata { name: "dest", ty: "<T::Lookup as StaticLookup>::Source" }, FunctionArgumentMetadata { name: "value", ty: "Compact<T::Balance>" }], documentation: [" Transfer some liquid free balance to another account.", "", " `transfer` will set the `FreeBalance` of the sender and receiver.", " It will decrease the total issuance of the system by the `TransferFee`.", " If the sender\'s account is below the existential deposit as a result", " of the transfer, the account will be reaped.", "", " The dispatch origin for this call must be `Signed` by the transactor."] }, FunctionMetadata { name: "set_balance", arguments: [FunctionArgumentMetadata { name: "who", ty: "<T::Lookup as StaticLookup>::Source" }, FunctionArgumentMetadata { name: "free", ty: "Compact<T::Balance>" }, FunctionArgumentMetadata { name: "reserved", ty: "Compact<T::Balance>" }], documentation: [" Set the balances of a given account.", "", " This will alter `FreeBalance` and `ReservedBalance` in storage.", " If the new free or reserved balance is below the existential deposit,", " it will also decrease the total issuance of the system (`TotalIssuance`)", " and reset the account nonce (`system::AccountNonce`).", "", " The dispatch origin for this call is `root`."] }]), event: Some([EventMetadata { name: "NewAccount", arguments: ["AccountId", "Balance"], documentation: [" A new account was created."] }, EventMetadata { name: "ReapedAccount", arguments: ["AccountId"], documentation: [" An account was reaped."] }, EventMetadata { name: "Transfer", arguments: ["AccountId", "AccountId", "Balance", "Balance"], documentation: [" Transfer succeeded (from, to, value, fees)."] }]) }, ModuleMetadata { name: "session", prefix: "Session", storage: Some([StorageFunctionMetadata { name: "Validators", modifier: Default, ty: Plain("Vec<T::AccountId>"), default: [0], documentation: [" The current set of validators."] }, StorageFunctionMetadata { name: "SessionLength", modifier: Default, ty: Plain("T::BlockNumber"), default: [232, 3, 0, 0, 0, 0, 0, 0], documentation: [" Current length of the session."] }, StorageFunctionMetadata { name: "CurrentIndex", modifier: Default, ty: Plain("T::BlockNumber"), default: [0, 0, 0, 0, 0, 0, 0, 0], documentation: [" Current index of the session."] }, StorageFunctionMetadata { name: "CurrentStart", modifier: Default, ty: Plain("T::Moment"), default: [0, 0, 0, 0, 0, 0, 0, 0], documentation: [" Timestamp when current session started."] }, StorageFunctionMetadata { name: "ForcingNewSession", modifier: Optional, ty: Plain("bool"), default: [0], documentation: [" New session is being forced if this entry exists; in which case, the boolean value is whether", " the new session should be considered a normal rotation (rewardable) or exceptional (slashable)."] }, StorageFunctionMetadata { name: "LastLengthChange", modifier: Optional, ty: Plain("T::BlockNumber"), default: [0], documentation: [" Block at which the session length last changed."] }, StorageFunctionMetadata { name: "NextKeyFor", modifier: Optional, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "T::SessionKey", is_linked: false }, default: [0], documentation: [" The next key for a given validator."] }, StorageFunctionMetadata { name: "NextSessionLength", modifier: Optional, ty: Plain("T::BlockNumber"), default: [0], documentation: [" The next session length."] }]), calls: Some([FunctionMetadata { name: "set_key", arguments: [FunctionArgumentMetadata { name: "key", ty: "T::SessionKey" }], documentation: [" Sets the session key of `_validator` to `_key`. This doesn\'t take effect until the next", " session."] }, FunctionMetadata { name: "set_length", arguments: [FunctionArgumentMetadata { name: "new", ty: "Compact<T::BlockNumber>" }], documentation: [" Set a new session length. Won\'t kick in until the next session change (at current length)."] }, FunctionMetadata { name: "force_new_session", arguments: [FunctionArgumentMetadata { name: "apply_rewards", ty: "bool" }], documentation: [" Forces a new session."] }]), event: Some([EventMetadata { name: "NewSession", arguments: ["BlockNumber"], documentation: [" New session has happened. Note that the argument is the session index, not the block", " number as the type might suggest."] }]) }, ModuleMetadata { name: "staking", prefix: "Staking", storage: Some([StorageFunctionMetadata { name: "ValidatorCount", modifier: Default, ty: Plain("u32"), default: [0, 0, 0, 0], documentation: [" The ideal number of staking participants."] }, StorageFunctionMetadata { name: "MinimumValidatorCount", modifier: Default, ty: Plain("u32"), default: [4, 0, 0, 0], documentation: [" Minimum number of staking participants before emergency conditions are imposed."] }, StorageFunctionMetadata { name: "SessionsPerEra", modifier: Default, ty: Plain("T::BlockNumber"), default: [232, 3, 0, 0, 0, 0, 0, 0], documentation: [" The length of a staking era in sessions."] }, StorageFunctionMetadata { name: "SessionReward", modifier: Default, ty: Plain("Perbill"), default: [60, 0, 0, 0], documentation: [" Maximum reward, per validator, that is provided per acceptable session."] }, StorageFunctionMetadata { name: "OfflineSlash", modifier: Default, ty: Plain("Perbill"), default: [64, 66, 15, 0], documentation: [" Slash, per validator that is taken for the first time they are found to be offline."] }, StorageFunctionMetadata { name: "OfflineSlashGrace", modifier: Default, ty: Plain("u32"), default: [0, 0, 0, 0], documentation: [" Number of instances of offline reports before slashing begins for validators."] }, StorageFunctionMetadata { name: "BondingDuration", modifier: Default, ty: Plain("T::BlockNumber"), default: [232, 3, 0, 0, 0, 0, 0, 0], documentation: [" The length of the bonding duration in blocks."] }, StorageFunctionMetadata { name: "Invulnerables", modifier: Default, ty: Plain("Vec<T::AccountId>"), default: [0], documentation: [" Any validators that may never be slashed or forcibly kicked. It\'s a Vec since they\'re easy to initialize", " and the performance hit is minimal (we expect no more than four invulnerables) and restricted to testnets."] }, StorageFunctionMetadata { name: "Bonded", modifier: Optional, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "T::AccountId", is_linked: false }, default: [0], documentation: [" Map from all locked \"stash\" accounts to the controller account."] }, StorageFunctionMetadata { name: "Ledger", modifier: Optional, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "StakingLedger<T::AccountId, BalanceOf<T>, T::BlockNumber>", is_linked: false }, default: [0], documentation: [" Map from all (unlocked) \"controller\" accounts to the info regarding the staking."] }, StorageFunctionMetadata { name: "Payee", modifier: Default, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "RewardDestination", is_linked: false }, default: [0], documentation: [" Where the reward payment should be made. Keyed by stash."] }, StorageFunctionMetadata { name: "Validators", modifier: Default, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "ValidatorPrefs<BalanceOf<T>>", is_linked: true }, default: [12, 0], documentation: [" The map from (wannabe) validator stash key to the preferences of that validator."] }, StorageFunctionMetadata { name: "Nominators", modifier: Default, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "Vec<T::AccountId>", is_linked: true }, default: [0], documentation: [" The map from nominator stash key to the set of stash keys of all validators to nominate."] }, StorageFunctionMetadata { name: "Stakers", modifier: Default, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "Exposure<T::AccountId, BalanceOf<T>>", is_linked: false }, default: [0, 0, 0], documentation: [" Nominators for a particular account that is in action right now. You can\'t iterate through validators here,", " but you can find them in the `sessions` module.", "", " This is keyed by the stash account."] }, StorageFunctionMetadata { name: "CurrentElected", modifier: Default, ty: Plain("Vec<T::AccountId>"), default: [0], documentation: [" The currently elected validator set keyed by stash account ID."] }, StorageFunctionMetadata { name: "CurrentEra", modifier: Default, ty: Plain("T::BlockNumber"), default: [0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The current era index."] }, StorageFunctionMetadata { name: "CurrentSessionReward", modifier: Default, ty: Plain("BalanceOf<T>"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" Maximum reward, per validator, that is provided per acceptable session."] }, StorageFunctionMetadata { name: "CurrentEraReward", modifier: Default, ty: Plain("BalanceOf<T>"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The accumulated reward for the current era. Reset to zero at the beginning of the era and", " increased for every successfully finished session."] }, StorageFunctionMetadata { name: "NextSessionsPerEra", modifier: Optional, ty: Plain("T::BlockNumber"), default: [0], documentation: [" The next value of sessions per era."] }, StorageFunctionMetadata { name: "LastEraLengthChange", modifier: Default, ty: Plain("T::BlockNumber"), default: [0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The session index at which the era length last changed."] }, StorageFunctionMetadata { name: "SlotStake", modifier: Default, ty: Plain("BalanceOf<T>"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The amount of balance actively at stake for each validator slot, currently.", "", " This is used to derive rewards and punishments."] }, StorageFunctionMetadata { name: "SlashCount", modifier: Default, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "u32", is_linked: false }, default: [0, 0, 0, 0], documentation: [" The number of times a given validator has been reported offline. This gets decremented by one each era that passes."] }, StorageFunctionMetadata { name: "ForcingNewEra", modifier: Optional, ty: Plain("()"), default: [0], documentation: [" We are forcing a new era."] }, StorageFunctionMetadata { name: "RecentlyOffline", modifier: Default, ty: Plain("Vec<(T::AccountId, T::BlockNumber, u32)>"), default: [0], documentation: [" Most recent `RECENT_OFFLINE_COUNT` instances. (who it was, when it was reported, how many instances they were offline for)."] }]), calls: Some([FunctionMetadata { name: "bond", arguments: [FunctionArgumentMetadata { name: "controller", ty: "<T::Lookup as StaticLookup>::Source" }, FunctionArgumentMetadata { name: "value", ty: "Compact<BalanceOf<T>>" }, FunctionArgumentMetadata { name: "payee", ty: "RewardDestination" }], documentation: [" Take the origin account as a stash and lock up `value` of its balance. `controller` will be the", " account that controls it.", "", " The dispatch origin for this call must be _Signed_ by the stash account."] }, FunctionMetadata { name: "bond_extra", arguments: [FunctionArgumentMetadata { name: "max_additional", ty: "Compact<BalanceOf<T>>" }], documentation: [" Add some extra amount that have appeared in the stash `free_balance` into the balance up for", " staking.", "", " Use this if there are additional funds in your stash account that you wish to bond.", "", " The dispatch origin for this call must be _Signed_ by the stash, not the controller."] }, FunctionMetadata { name: "unbond", arguments: [FunctionArgumentMetadata { name: "value", ty: "Compact<BalanceOf<T>>" }], documentation: [" Schedule a portion of the stash to be unlocked ready for transfer out after the bond", " period ends. If this leaves an amount actively bonded less than", " T::Currency::existential_deposit(), then it is increased to the full amount.", "", " Once the unlock period is done, you can call `withdraw_unbonded` to actually move", " the funds out of management ready for transfer.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " See also [`Call::withdraw_unbonded`]."] }, FunctionMetadata { name: "withdraw_unbonded", arguments: [], documentation: [" Remove any unlocked chunks from the `unlocking` queue from our management.", "", " This essentially frees up that balance to be used by the stash account to do", " whatever it wants.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " See also [`Call::unbond`]."] }, FunctionMetadata { name: "validate", arguments: [FunctionArgumentMetadata { name: "prefs", ty: "ValidatorPrefs<BalanceOf<T>>" }], documentation: [" Declare the desire to validate for the origin controller.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash."] }, FunctionMetadata { name: "nominate", arguments: [FunctionArgumentMetadata { name: "targets", ty: "Vec<<T::Lookup as StaticLookup>::Source>" }], documentation: [" Declare the desire to nominate `targets` for the origin controller.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash."] }, FunctionMetadata { name: "chill", arguments: [], documentation: [" Declare no desire to either validate or nominate.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash."] }, FunctionMetadata { name: "set_payee", arguments: [FunctionArgumentMetadata { name: "payee", ty: "RewardDestination" }], documentation: [" (Re-)set the payment target for a controller.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash."] }, FunctionMetadata { name: "set_controller", arguments: [FunctionArgumentMetadata { name: "controller", ty: "<T::Lookup as StaticLookup>::Source" }], documentation: [" (Re-)set the payment target for a controller.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the stash, not the controller."] }, FunctionMetadata { name: "set_sessions_per_era", arguments: [FunctionArgumentMetadata { name: "new", ty: "Compact<T::BlockNumber>" }], documentation: [" Set the number of sessions in an era."] }, FunctionMetadata { name: "set_bonding_duration", arguments: [FunctionArgumentMetadata { name: "new", ty: "Compact<T::BlockNumber>" }], documentation: [" The length of the bonding duration in eras."] }, FunctionMetadata { name: "set_validator_count", arguments: [FunctionArgumentMetadata { name: "new", ty: "Compact<u32>" }], documentation: [" The ideal number of validators."] }, FunctionMetadata { name: "force_new_era", arguments: [FunctionArgumentMetadata { name: "apply_rewards", ty: "bool" }], documentation: [" Force there to be a new era. This also forces a new session immediately after.", " `apply_rewards` should be true for validators to get the session reward."] }, FunctionMetadata { name: "set_offline_slash_grace", arguments: [FunctionArgumentMetadata { name: "new", ty: "Compact<u32>" }], documentation: [" Set the offline slash grace period."] }, FunctionMetadata { name: "set_invulnerables", arguments: [FunctionArgumentMetadata { name: "validators", ty: "Vec<T::AccountId>" }], documentation: [" Set the validators who cannot be slashed (if any)."] }]), event: Some([EventMetadata { name: "Reward", arguments: ["Balance"], documentation: [" All validators have been rewarded by the given balance."] }, EventMetadata { name: "OfflineWarning", arguments: ["AccountId", "u32"], documentation: [" One validator (and their nominators) has been given a offline-warning (they\'re still", " within their grace). The accrued number of slashes is recorded, too."] }, EventMetadata { name: "OfflineSlash", arguments: ["AccountId", "Balance"], documentation: [" One validator (and their nominators) has been slashed by the given amount."] }]) }, ModuleMetadata { name: "democracy", prefix: "Democracy", storage: Some([StorageFunctionMetadata { name: "PublicPropCount", modifier: Default, ty: Plain("PropIndex"), default: [0, 0, 0, 0], documentation: [" The number of (public) proposals that have been made so far."] }, StorageFunctionMetadata { name: "PublicProps", modifier: Default, ty: Plain("Vec<(PropIndex, T::Proposal, T::AccountId)>"), default: [0], documentation: [" The public proposals. Unsorted."] }, StorageFunctionMetadata { name: "DepositOf", modifier: Optional, ty: Map { hasher: Blake2_256, key: "PropIndex", value: "(BalanceOf<T>, Vec<T::AccountId>)", is_linked: false }, default: [0], documentation: [" Those who have locked a deposit."] }, StorageFunctionMetadata { name: "LaunchPeriod", modifier: Default, ty: Plain("T::BlockNumber"), default: [232, 3, 0, 0, 0, 0, 0, 0], documentation: [" How often (in blocks) new public referenda are launched."] }, StorageFunctionMetadata { name: "MinimumDeposit", modifier: Default, ty: Plain("BalanceOf<T>"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The minimum amount to be used as a deposit for a public referendum proposal."] }, StorageFunctionMetadata { name: "PublicDelay", modifier: Default, ty: Plain("T::BlockNumber"), default: [0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The delay before enactment for all public referenda."] }, StorageFunctionMetadata { name: "MaxLockPeriods", modifier: Default, ty: Plain("LockPeriods"), default: [0], documentation: [" The maximum number of additional lock periods a voter may offer to strengthen their vote. Multiples of `PublicDelay`."] }, StorageFunctionMetadata { name: "VotingPeriod", modifier: Default, ty: Plain("T::BlockNumber"), default: [232, 3, 0, 0, 0, 0, 0, 0], documentation: [" How often (in blocks) to check for new votes."] }, StorageFunctionMetadata { name: "ReferendumCount", modifier: Default, ty: Plain("ReferendumIndex"), default: [0, 0, 0, 0], documentation: [" The next free referendum index, aka the number of referendums started so far."] }, StorageFunctionMetadata { name: "NextTally", modifier: Default, ty: Plain("ReferendumIndex"), default: [0, 0, 0, 0], documentation: [" The next referendum index that should be tallied."] }, StorageFunctionMetadata { name: "ReferendumInfoOf", modifier: Optional, ty: Map { hasher: Blake2_256, key: "ReferendumIndex", value: "(ReferendumInfo<T::BlockNumber, T::Proposal>)", is_linked: false }, default: [0], documentation: [" Information concerning any given referendum."] }, StorageFunctionMetadata { name: "DispatchQueue", modifier: Default, ty: Map { hasher: Blake2_256, key: "T::BlockNumber", value: "Vec<Option<(T::Proposal, ReferendumIndex)>>", is_linked: false }, default: [0], documentation: [" Queue of successful referenda to be dispatched."] }, StorageFunctionMetadata { name: "VotersFor", modifier: Default, ty: Map { hasher: Blake2_256, key: "ReferendumIndex", value: "Vec<T::AccountId>", is_linked: false }, default: [0], documentation: [" Get the voters for the current proposal."] }, StorageFunctionMetadata { name: "VoteOf", modifier: Default, ty: Map { hasher: Blake2_256, key: "(ReferendumIndex, T::AccountId)", value: "Vote", is_linked: false }, default: [0], documentation: [" Get the vote in a given referendum of a particular voter. The result is meaningful only if `voters_for` includes the", " voter when called with the referendum (you\'ll get the default `Vote` value otherwise). If you don\'t want to check", " `voters_for`, then you can also check for simple existence with `VoteOf::exists` first."] }, StorageFunctionMetadata { name: "Proxy", modifier: Optional, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "T::AccountId", is_linked: false }, default: [0], documentation: [" Who is able to vote for whom. Value is the fund-holding account, key is the vote-transaction-sending account."] }, StorageFunctionMetadata { name: "Delegations", modifier: Default, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "(T::AccountId, LockPeriods)", is_linked: true }, default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" Get the account (and lock periods) to which another account is delegating vote."] }]), calls: Some([FunctionMetadata { name: "propose", arguments: [FunctionArgumentMetadata { name: "proposal", ty: "Box<T::Proposal>" }, FunctionArgumentMetadata { name: "value", ty: "Compact<BalanceOf<T>>" }], documentation: [" Propose a sensitive action to be taken."] }, FunctionMetadata { name: "second", arguments: [FunctionArgumentMetadata { name: "proposal", ty: "Compact<PropIndex>" }], documentation: [" Propose a sensitive action to be taken."] }, FunctionMetadata { name: "vote", arguments: [FunctionArgumentMetadata { name: "ref_index", ty: "Compact<ReferendumIndex>" }, FunctionArgumentMetadata { name: "vote", ty: "Vote" }], documentation: [" Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;", " otherwise it is a vote to keep the status quo."] }, FunctionMetadata { name: "proxy_vote", arguments: [FunctionArgumentMetadata { name: "ref_index", ty: "Compact<ReferendumIndex>" }, FunctionArgumentMetadata { name: "vote", ty: "Vote" }], documentation: [" Vote in a referendum on behalf of a stash. If `vote.is_aye()`, the vote is to enact the proposal;", " otherwise it is a vote to keep the status quo."] }, FunctionMetadata { name: "start_referendum", arguments: [FunctionArgumentMetadata { name: "proposal", ty: "Box<T::Proposal>" }, FunctionArgumentMetadata { name: "threshold", ty: "VoteThreshold" }, FunctionArgumentMetadata { name: "delay", ty: "T::BlockNumber" }], documentation: [" Start a referendum."] }, FunctionMetadata { name: "cancel_referendum", arguments: [FunctionArgumentMetadata { name: "ref_index", ty: "Compact<ReferendumIndex>" }], documentation: [" Remove a referendum."] }, FunctionMetadata { name: "cancel_queued", arguments: [FunctionArgumentMetadata { name: "when", ty: "Compact<T::BlockNumber>" }, FunctionArgumentMetadata { name: "which", ty: "Compact<u32>" }], documentation: [" Cancel a proposal queued for enactment."] }, FunctionMetadata { name: "set_proxy", arguments: [FunctionArgumentMetadata { name: "proxy", ty: "T::AccountId" }], documentation: [" Specify a proxy. Called by the stash."] }, FunctionMetadata { name: "resign_proxy", arguments: [], documentation: [" Clear the proxy. Called by the proxy."] }, FunctionMetadata { name: "remove_proxy", arguments: [FunctionArgumentMetadata { name: "proxy", ty: "T::AccountId" }], documentation: [" Clear the proxy. Called by the stash."] }, FunctionMetadata { name: "delegate", arguments: [FunctionArgumentMetadata { name: "to", ty: "T::AccountId" }, FunctionArgumentMetadata { name: "lock_periods", ty: "LockPeriods" }], documentation: [" Delegate vote."] }, FunctionMetadata { name: "undelegate", arguments: [], documentation: [" Undelegate vote."] }]), event: Some([EventMetadata { name: "Proposed", arguments: ["PropIndex", "Balance"], documentation: [] }, EventMetadata { name: "Tabled", arguments: ["PropIndex", "Balance", "Vec<AccountId>"], documentation: [] }, EventMetadata { name: "Started", arguments: ["ReferendumIndex", "VoteThreshold"], documentation: [] }, EventMetadata { name: "Passed", arguments: ["ReferendumIndex"], documentation: [] }, EventMetadata { name: "NotPassed", arguments: ["ReferendumIndex"], documentation: [] }, EventMetadata { name: "Cancelled", arguments: ["ReferendumIndex"], documentation: [] }, EventMetadata { name: "Executed", arguments: ["ReferendumIndex", "bool"], documentation: [] }, EventMetadata { name: "Delegated", arguments: ["AccountId", "AccountId"], documentation: [] }, EventMetadata { name: "Undelegated", arguments: ["AccountId"], documentation: [] }]) }, ModuleMetadata { name: "council", prefix: "Council", storage: Some([StorageFunctionMetadata { name: "CandidacyBond", modifier: Default, ty: Plain("BalanceOf<T>"), default: [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" How much should be locked up in order to submit one\'s candidacy."] }, StorageFunctionMetadata { name: "VotingBond", modifier: Default, ty: Plain("BalanceOf<T>"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" How much should be locked up in order to be able to submit votes."] }, StorageFunctionMetadata { name: "PresentSlashPerVoter", modifier: Default, ty: Plain("BalanceOf<T>"), default: [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The punishment, per voter, if you provide an invalid presentation."] }, StorageFunctionMetadata { name: "CarryCount", modifier: Default, ty: Plain("u32"), default: [2, 0, 0, 0], documentation: [" How many runners-up should have their approvals persist until the next vote."] }, StorageFunctionMetadata { name: "PresentationDuration", modifier: Default, ty: Plain("T::BlockNumber"), default: [232, 3, 0, 0, 0, 0, 0, 0], documentation: [" How long to give each top candidate to present themselves after the vote ends."] }, StorageFunctionMetadata { name: "InactiveGracePeriod", modifier: Default, ty: Plain("VoteIndex"), default: [1, 0, 0, 0], documentation: [" How many vote indexes need to go by after a target voter\'s last vote before they can be reaped if their", " approvals are moot."] }, StorageFunctionMetadata { name: "VotingPeriod", modifier: Default, ty: Plain("T::BlockNumber"), default: [232, 3, 0, 0, 0, 0, 0, 0], documentation: [" How often (in blocks) to check for new votes."] }, StorageFunctionMetadata { name: "TermDuration", modifier: Default, ty: Plain("T::BlockNumber"), default: [5, 0, 0, 0, 0, 0, 0, 0], documentation: [" How long each position is active for."] }, StorageFunctionMetadata { name: "DesiredSeats", modifier: Default, ty: Plain("u32"), default: [0, 0, 0, 0], documentation: [" Number of accounts that should be sitting on the council."] }, StorageFunctionMetadata { name: "ActiveCouncil", modifier: Default, ty: Plain("Vec<(T::AccountId, T::BlockNumber)>"), default: [0], documentation: [" The current council. When there\'s a vote going on, this should still be used for executive", " matters. The block number (second element in the tuple) is the block that their position is", " active until (calculated by the sum of the block number when the council member was elected", " and their term duration)."] }, StorageFunctionMetadata { name: "VoteCount", modifier: Default, ty: Plain("VoteIndex"), default: [0, 0, 0, 0], documentation: [" The total number of votes that have happened or are in progress."] }, StorageFunctionMetadata { name: "ApprovalsOf", modifier: Default, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "Vec<bool>", is_linked: false }, default: [0], documentation: [" A list of votes for each voter, respecting the last cleared vote index that this voter was", " last active at."] }, StorageFunctionMetadata { name: "RegisterInfoOf", modifier: Optional, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "(VoteIndex, u32)", is_linked: false }, default: [0], documentation: [" The vote index and list slot that the candidate `who` was registered or `None` if they are not", " currently registered."] }, StorageFunctionMetadata { name: "LastActiveOf", modifier: Optional, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "VoteIndex", is_linked: false }, default: [0], documentation: [" The last cleared vote index that this voter was last active at."] }, StorageFunctionMetadata { name: "Voters", modifier: Default, ty: Plain("Vec<T::AccountId>"), default: [0], documentation: [" The present voter list."] }, StorageFunctionMetadata { name: "Candidates", modifier: Default, ty: Plain("Vec<T::AccountId>"), default: [0], documentation: [" The present candidate list."] }, StorageFunctionMetadata { name: "CandidateCount", modifier: Default, ty: Plain("u32"), default: [0, 0, 0, 0], documentation: [] }, StorageFunctionMetadata { name: "NextFinalize", modifier: Optional, ty: Plain("(T::BlockNumber, u32, Vec<T::AccountId>)"), default: [0], documentation: [" The accounts holding the seats that will become free on the next tally."] }, StorageFunctionMetadata { name: "SnapshotedStakes", modifier: Default, ty: Plain("Vec<BalanceOf<T>>"), default: [0], documentation: [" The stakes as they were at the point that the vote ended."] }, StorageFunctionMetadata { name: "Leaderboard", modifier: Optional, ty: Plain("Vec<(BalanceOf<T>, T::AccountId)>"), default: [0], documentation: [" Get the leaderboard if we\'re in the presentation phase."] }]), calls: Some([FunctionMetadata { name: "set_approvals", arguments: [FunctionArgumentMetadata { name: "votes", ty: "Vec<bool>" }, FunctionArgumentMetadata { name: "index", ty: "Compact<VoteIndex>" }], documentation: [" Set candidate approvals. Approval slots stay valid as long as candidates in those slots", " are registered."] }, FunctionMetadata { name: "proxy_set_approvals", arguments: [FunctionArgumentMetadata { name: "votes", ty: "Vec<bool>" }, FunctionArgumentMetadata { name: "index", ty: "Compact<VoteIndex>" }], documentation: [" Set candidate approvals from a proxy. Approval slots stay valid as long as candidates in those slots", " are registered."] }, FunctionMetadata { name: "reap_inactive_voter", arguments: [FunctionArgumentMetadata { name: "reporter_index", ty: "Compact<u32>" }, FunctionArgumentMetadata { name: "who", ty: "<T::Lookup as StaticLookup>::Source" }, FunctionArgumentMetadata { name: "who_index", ty: "Compact<u32>" }, FunctionArgumentMetadata { name: "assumed_vote_index", ty: "Compact<VoteIndex>" }], documentation: [" Remove a voter. For it not to be a bond-consuming no-op, all approved candidate indices", " must now be either unregistered or registered to a candidate that registered the slot after", " the voter gave their last approval set.", "", " May be called by anyone. Returns the voter deposit to `signed`."] }, FunctionMetadata { name: "retract_voter", arguments: [FunctionArgumentMetadata { name: "index", ty: "Compact<u32>" }], documentation: [" Remove a voter. All votes are cancelled and the voter deposit is returned."] }, FunctionMetadata { name: "submit_candidacy", arguments: [FunctionArgumentMetadata { name: "slot", ty: "Compact<u32>" }], documentation: [" Submit oneself for candidacy.", "", " Account must have enough transferrable funds in it to pay the bond."] }, FunctionMetadata { name: "present_winner", arguments: [FunctionArgumentMetadata { name: "candidate", ty: "<T::Lookup as StaticLookup>::Source" }, FunctionArgumentMetadata { name: "total", ty: "Compact<BalanceOf<T>>" }, FunctionArgumentMetadata { name: "index", ty: "Compact<VoteIndex>" }], documentation: [" Claim that `signed` is one of the top Self::carry_count() + current_vote().1 candidates.", " Only works if the `block_number >= current_vote().0` and `< current_vote().0 + presentation_duration()``", " `signed` should have at least"] }, FunctionMetadata { name: "set_desired_seats", arguments: [FunctionArgumentMetadata { name: "count", ty: "Compact<u32>" }], documentation: [" Set the desired member count; if lower than the current count, then seats will not be up", " election when they expire. If more, then a new vote will be started if one is not already", " in progress."] }, FunctionMetadata { name: "remove_member", arguments: [FunctionArgumentMetadata { name: "who", ty: "<T::Lookup as StaticLookup>::Source" }], documentation: [" Remove a particular member. A tally will happen instantly (if not already in a presentation", " period) to fill the seat if removal means that the desired members are not met.", " This is effective immediately."] }, FunctionMetadata { name: "set_presentation_duration", arguments: [FunctionArgumentMetadata { name: "count", ty: "Compact<T::BlockNumber>" }], documentation: [" Set the presentation duration. If there is currently a vote being presented for, will", " invoke `finalize_vote`."] }, FunctionMetadata { name: "set_term_duration", arguments: [FunctionArgumentMetadata { name: "count", ty: "Compact<T::BlockNumber>" }], documentation: [" Set the presentation duration. If there is current a vote being presented for, will", " invoke `finalize_vote`."] }]), event: Some([EventMetadata { name: "VoterReaped", arguments: ["AccountId", "AccountId"], documentation: [" reaped voter, reaper"] }, EventMetadata { name: "BadReaperSlashed", arguments: ["AccountId"], documentation: [" slashed reaper"] }, EventMetadata { name: "TallyStarted", arguments: ["u32"], documentation: [" A tally (for approval votes of council seat(s)) has started."] }, EventMetadata { name: "TallyFinalized", arguments: ["Vec<AccountId>", "Vec<AccountId>"], documentation: [" A tally (for approval votes of council seat(s)) has ended (with one or more new members)."] }]) }, ModuleMetadata { name: "council_voting", prefix: "CouncilVoting", storage: Some([StorageFunctionMetadata { name: "CooloffPeriod", modifier: Default, ty: Plain("T::BlockNumber"), default: [232, 3, 0, 0, 0, 0, 0, 0], documentation: [] }, StorageFunctionMetadata { name: "VotingPeriod", modifier: Default, ty: Plain("T::BlockNumber"), default: [3, 0, 0, 0, 0, 0, 0, 0], documentation: [] }, StorageFunctionMetadata { name: "EnactDelayPeriod", modifier: Default, ty: Plain("T::BlockNumber"), default: [0, 0, 0, 0, 0, 0, 0, 0], documentation: [" Number of blocks by which to delay enactment of successful, non-unanimous-council-instigated referendum proposals."] }, StorageFunctionMetadata { name: "Proposals", modifier: Default, ty: Plain("Vec<(T::BlockNumber, T::Hash)>"), default: [0], documentation: [] }, StorageFunctionMetadata { name: "ProposalOf", modifier: Optional, ty: Map { hasher: Blake2_256, key: "T::Hash", value: "T::Proposal", is_linked: false }, default: [0], documentation: [] }, StorageFunctionMetadata { name: "ProposalVoters", modifier: Default, ty: Map { hasher: Blake2_256, key: "T::Hash", value: "Vec<T::AccountId>", is_linked: false }, default: [0], documentation: [] }, StorageFunctionMetadata { name: "CouncilVoteOf", modifier: Optional, ty: Map { hasher: Blake2_256, key: "(T::Hash, T::AccountId)", value: "bool", is_linked: false }, default: [0], documentation: [] }, StorageFunctionMetadata { name: "VetoedProposal", modifier: Optional, ty: Map { hasher: Blake2_256, key: "T::Hash", value: "(T::BlockNumber, Vec<T::AccountId>)", is_linked: false }, default: [0], documentation: [] }]), calls: Some([FunctionMetadata { name: "propose", arguments: [FunctionArgumentMetadata { name: "proposal", ty: "Box<T::Proposal>" }], documentation: [] }, FunctionMetadata { name: "vote", arguments: [FunctionArgumentMetadata { name: "proposal", ty: "T::Hash" }, FunctionArgumentMetadata { name: "approve", ty: "bool" }], documentation: [] }, FunctionMetadata { name: "veto", arguments: [FunctionArgumentMetadata { name: "proposal_hash", ty: "T::Hash" }], documentation: [] }, FunctionMetadata { name: "set_cooloff_period", arguments: [FunctionArgumentMetadata { name: "blocks", ty: "Compact<T::BlockNumber>" }], documentation: [] }, FunctionMetadata { name: "set_voting_period", arguments: [FunctionArgumentMetadata { name: "blocks", ty: "Compact<T::BlockNumber>" }], documentation: [] }]), event: Some([EventMetadata { name: "TallyCancelation", arguments: ["Hash", "u32", "u32", "u32"], documentation: [" A voting tally has happened for a referendum cancellation vote.", " Last three are yes, no, abstain counts."] }, EventMetadata { name: "TallyReferendum", arguments: ["Hash", "u32", "u32", "u32"], documentation: [" A voting tally has happened for a referendum vote.", " Last three are yes, no, abstain counts."] }]) }, ModuleMetadata { name: "council_motions", prefix: "CouncilMotions", storage: Some([StorageFunctionMetadata { name: "Proposals", modifier: Default, ty: Plain("Vec<T::Hash>"), default: [0], documentation: [" The (hashes of) the active proposals."] }, StorageFunctionMetadata { name: "ProposalOf", modifier: Optional, ty: Map { hasher: Blake2_256, key: "T::Hash", value: "<T as Trait>::Proposal", is_linked: false }, default: [0], documentation: [" Actual proposal for a given hash, if it\'s current."] }, StorageFunctionMetadata { name: "Voting", modifier: Optional, ty: Map { hasher: Blake2_256, key: "T::Hash", value: "(ProposalIndex, u32, Vec<T::AccountId>, Vec<T::AccountId>)", is_linked: false }, default: [0], documentation: [" Votes for a given proposal: (required_yes_votes, yes_voters, no_voters)."] }, StorageFunctionMetadata { name: "ProposalCount", modifier: Default, ty: Plain("u32"), default: [0, 0, 0, 0], documentation: [" Proposals so far."] }]), calls: Some([FunctionMetadata { name: "propose", arguments: [FunctionArgumentMetadata { name: "threshold", ty: "Compact<u32>" }, FunctionArgumentMetadata { name: "proposal", ty: "Box<<T as Trait>::Proposal>" }], documentation: [] }, FunctionMetadata { name: "vote", arguments: [FunctionArgumentMetadata { name: "proposal", ty: "T::Hash" }, FunctionArgumentMetadata { name: "index", ty: "Compact<ProposalIndex>" }, FunctionArgumentMetadata { name: "approve", ty: "bool" }], documentation: [] }]), event: Some([EventMetadata { name: "Proposed", arguments: ["AccountId", "ProposalIndex", "Hash", "u32"], documentation: [" A motion (given hash) has been proposed (by given account) with a threshold (given u32)."] }, EventMetadata { name: "Voted", arguments: ["AccountId", "Hash", "bool", "u32", "u32"], documentation: [" A motion (given hash) has been voted on by given account, leaving", " a tally (yes votes and no votes given as u32s respectively)."] }, EventMetadata { name: "Approved", arguments: ["Hash"], documentation: [" A motion was approved by the required threshold."] }, EventMetadata { name: "Disapproved", arguments: ["Hash"], documentation: [" A motion was not approved by the required threshold."] }, EventMetadata { name: "Executed", arguments: ["Hash", "bool"], documentation: [" A motion was executed; `bool` is true if returned without error."] }]) }, ModuleMetadata { name: "finality_tracker", prefix: "", storage: None, calls: Some([FunctionMetadata { name: "final_hint", arguments: [FunctionArgumentMetadata { name: "hint", ty: "Compact<T::BlockNumber>" }], documentation: [" Hint that the author of this block thinks the best finalized", " block is the given number."] }]), event: None }, ModuleMetadata { name: "grandpa", prefix: "GrandpaFinality", storage: Some([StorageFunctionMetadata { name: "PendingChange", modifier: Optional, ty: Plain("StoredPendingChange<T::BlockNumber, T::SessionKey>"), default: [0], documentation: [] }, StorageFunctionMetadata { name: "NextForced", modifier: Optional, ty: Plain("T::BlockNumber"), default: [0], documentation: [] }]), calls: Some([FunctionMetadata { name: "report_misbehavior", arguments: [FunctionArgumentMetadata { name: "_report", ty: "Vec<u8>" }], documentation: [" Report some misbehavior."] }]), event: Some([EventMetadata { name: "NewAuthorities", arguments: ["Vec<(SessionKey, u64)>"], documentation: [" New authority set has been applied."] }]) }, ModuleMetadata { name: "treasury", prefix: "Treasury", storage: Some([StorageFunctionMetadata { name: "ProposalBond", modifier: Default, ty: Plain("Permill"), default: [0, 0, 0, 0], documentation: [" Proportion of funds that should be bonded in order to place a proposal. An accepted", " proposal gets these back. A rejected proposal doesn\'t."] }, StorageFunctionMetadata { name: "ProposalBondMinimum", modifier: Default, ty: Plain("BalanceOf<T>"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" Minimum amount of funds that should be placed in a deposit for making a proposal."] }, StorageFunctionMetadata { name: "SpendPeriod", modifier: Default, ty: Plain("T::BlockNumber"), default: [1, 0, 0, 0, 0, 0, 0, 0], documentation: [" Period between successive spends."] }, StorageFunctionMetadata { name: "Burn", modifier: Default, ty: Plain("Permill"), default: [0, 0, 0, 0], documentation: [" Percentage of spare funds (if any) that are burnt per spend period."] }, StorageFunctionMetadata { name: "Pot", modifier: Default, ty: Plain("BalanceOf<T>"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" Total funds available to this module for spending."] }, StorageFunctionMetadata { name: "ProposalCount", modifier: Default, ty: Plain("ProposalIndex"), default: [0, 0, 0, 0], documentation: [" Number of proposals that have been made."] }, StorageFunctionMetadata { name: "Proposals", modifier: Optional, ty: Map { hasher: Blake2_256, key: "ProposalIndex", value: "Proposal<T::AccountId, BalanceOf<T>>", is_linked: false }, default: [0], documentation: [" Proposals that have been made."] }, StorageFunctionMetadata { name: "Approvals", modifier: Default, ty: Plain("Vec<ProposalIndex>"), default: [0], documentation: [" Proposal indices that have been approved but not yet awarded."] }]), calls: Some([FunctionMetadata { name: "propose_spend", arguments: [FunctionArgumentMetadata { name: "value", ty: "Compact<BalanceOf<T>>" }, FunctionArgumentMetadata { name: "beneficiary", ty: "<T::Lookup as StaticLookup>::Source" }], documentation: [" Put forward a suggestion for spending. A deposit proportional to the value", " is reserved and slashed if the proposal is rejected. It is returned once the", " proposal is awarded."] }, FunctionMetadata { name: "set_pot", arguments: [FunctionArgumentMetadata { name: "new_pot", ty: "Compact<BalanceOf<T>>" }], documentation: [" Set the balance of funds available to spend."] }, FunctionMetadata { name: "configure", arguments: [FunctionArgumentMetadata { name: "proposal_bond", ty: "Compact<Permill>" }, FunctionArgumentMetadata { name: "proposal_bond_minimum", ty: "Compact<BalanceOf<T>>" }, FunctionArgumentMetadata { name: "spend_period", ty: "Compact<T::BlockNumber>" }, FunctionArgumentMetadata { name: "burn", ty: "Compact<Permill>" }], documentation: [" (Re-)configure this module."] }, FunctionMetadata { name: "reject_proposal", arguments: [FunctionArgumentMetadata { name: "proposal_id", ty: "Compact<ProposalIndex>" }], documentation: [" Reject a proposed spend. The original deposit will be slashed."] }, FunctionMetadata { name: "approve_proposal", arguments: [FunctionArgumentMetadata { name: "proposal_id", ty: "Compact<ProposalIndex>" }], documentation: [" Approve a proposal. At a later time, the proposal will be allocated to the beneficiary", " and the original deposit will be returned."] }]), event: Some([EventMetadata { name: "Proposed", arguments: ["ProposalIndex"], documentation: [" New proposal."] }, EventMetadata { name: "Spending", arguments: ["Balance"], documentation: [" We have ended a spend period and will now allocate funds."] }, EventMetadata { name: "Awarded", arguments: ["ProposalIndex", "Balance", "AccountId"], documentation: [" Some funds have been allocated."] }, EventMetadata { name: "Burnt", arguments: ["Balance"], documentation: [" Some of our funds have been burnt."] }, EventMetadata { name: "Rollover", arguments: ["Balance"], documentation: [" Spending has finished; this is the amount that rolls over until next spend."] }]) }, ModuleMetadata { name: "contract", prefix: "Contract", storage: Some([StorageFunctionMetadata { name: "TransferFee", modifier: Default, ty: Plain("BalanceOf<T>"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The fee required to make a transfer."] }, StorageFunctionMetadata { name: "CreationFee", modifier: Default, ty: Plain("BalanceOf<T>"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The fee required to create an account."] }, StorageFunctionMetadata { name: "TransactionBaseFee", modifier: Default, ty: Plain("BalanceOf<T>"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The fee to be paid for making a transaction; the base."] }, StorageFunctionMetadata { name: "TransactionByteFee", modifier: Default, ty: Plain("BalanceOf<T>"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The fee to be paid for making a transaction; the per-byte portion."] }, StorageFunctionMetadata { name: "ContractFee", modifier: Default, ty: Plain("BalanceOf<T>"), default: [21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The fee required to create a contract instance."] }, StorageFunctionMetadata { name: "CallBaseFee", modifier: Default, ty: Plain("T::Gas"), default: [135, 0, 0, 0, 0, 0, 0, 0], documentation: [" The base fee charged for calling into a contract."] }, StorageFunctionMetadata { name: "CreateBaseFee", modifier: Default, ty: Plain("T::Gas"), default: [175, 0, 0, 0, 0, 0, 0, 0], documentation: [" The base fee charged for creating a contract."] }, StorageFunctionMetadata { name: "GasPrice", modifier: Default, ty: Plain("BalanceOf<T>"), default: [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The price of one unit of gas."] }, StorageFunctionMetadata { name: "MaxDepth", modifier: Default, ty: Plain("u32"), default: [100, 0, 0, 0], documentation: [" The maximum nesting level of a call/create stack."] }, StorageFunctionMetadata { name: "BlockGasLimit", modifier: Default, ty: Plain("T::Gas"), default: [64, 66, 15, 0, 0, 0, 0, 0], documentation: [" The maximum amount of gas that could be expended per block."] }, StorageFunctionMetadata { name: "GasSpent", modifier: Default, ty: Plain("T::Gas"), default: [0, 0, 0, 0, 0, 0, 0, 0], documentation: [" Gas spent so far in this block."] }, StorageFunctionMetadata { name: "CurrentSchedule", modifier: Default, ty: Plain("Schedule<T::Gas>"), default: [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 16, 0, 0, 0, 0], documentation: [" Current cost schedule for contracts."] }, StorageFunctionMetadata { name: "CodeHashOf", modifier: Optional, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "CodeHash<T>", is_linked: false }, default: [0], documentation: [" The code associated with a given account."] }, StorageFunctionMetadata { name: "PristineCode", modifier: Optional, ty: Map { hasher: Blake2_256, key: "CodeHash<T>", value: "Vec<u8>", is_linked: false }, default: [0], documentation: [" A mapping from an original code hash to the original code, untouched by instrumentation."] }, StorageFunctionMetadata { name: "CodeStorage", modifier: Optional, ty: Map { hasher: Blake2_256, key: "CodeHash<T>", value: "wasm::PrefabWasmModule", is_linked: false }, default: [0], documentation: [" A mapping between an original code hash and instrumented wasm code, ready for the execution."] }, StorageFunctionMetadata { name: "AccountCounter", modifier: Default, ty: Plain("u64"), default: [0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The subtrie counter"] }, StorageFunctionMetadata { name: "AccountInfoOf", modifier: Optional, ty: Map { hasher: Blake2_256, key: "T::AccountId", value: "AccountInfo", is_linked: false }, default: [0], documentation: [" The code associated with a given account."] }]), calls: Some([FunctionMetadata { name: "update_schedule", arguments: [FunctionArgumentMetadata { name: "schedule", ty: "Schedule<T::Gas>" }], documentation: [" Updates the schedule for metering contracts.", "", " The schedule must have a greater version than the stored schedule."] }, FunctionMetadata { name: "put_code", arguments: [FunctionArgumentMetadata { name: "gas_limit", ty: "Compact<T::Gas>" }, FunctionArgumentMetadata { name: "code", ty: "Vec<u8>" }], documentation: [" Stores the given binary Wasm code into the chains storage and returns its `codehash`.", " You can instantiate contracts only with stored code."] }, FunctionMetadata { name: "call", arguments: [FunctionArgumentMetadata { name: "dest", ty: "<T::Lookup as StaticLookup>::Source" }, FunctionArgumentMetadata { name: "value", ty: "Compact<BalanceOf<T>>" }, FunctionArgumentMetadata { name: "gas_limit", ty: "Compact<T::Gas>" }, FunctionArgumentMetadata { name: "data", ty: "Vec<u8>" }], documentation: [" Makes a call to an account, optionally transferring some balance.", "", " * If the account is a smart-contract account, the associated code will be", " executed and any value will be transferred.", " * If the account is a regular account, any value will be transferred.", " * If no account exists and the call value is not less than `existential_deposit`,", " a regular account will be created and any value will be transferred."] }, FunctionMetadata { name: "create", arguments: [FunctionArgumentMetadata { name: "endowment", ty: "Compact<BalanceOf<T>>" }, FunctionArgumentMetadata { name: "gas_limit", ty: "Compact<T::Gas>" }, FunctionArgumentMetadata { name: "code_hash", ty: "CodeHash<T>" }, FunctionArgumentMetadata { name: "data", ty: "Vec<u8>" }], documentation: [" Creates a new contract from the `codehash` generated by `put_code`, optionally transferring some balance.", "", " Creation is executed as follows:", "", " - the destination address is computed based on the sender and hash of the code.", " - the smart-contract account is created at the computed address.", " - the `ctor_code` is executed in the context of the newly created account. Buffer returned", "   after the execution is saved as the `code` of the account. That code will be invoked", "   upon any call received by this account.", " - The contract is initialized."] }]), event: Some([EventMetadata { name: "Transfer", arguments: ["AccountId", "AccountId", "Balance"], documentation: [" Transfer happened `from` to `to` with given `value` as part of a `call` or `create`."] }, EventMetadata { name: "Instantiated", arguments: ["AccountId", "AccountId"], documentation: [" Contract deployed by address at the specified address."] }, EventMetadata { name: "CodeStored", arguments: ["Hash"], documentation: [" Code with the specified hash has been stored."] }, EventMetadata { name: "ScheduleUpdated", arguments: ["u32"], documentation: [" Triggered when the current schedule is updated."] }, EventMetadata { name: "Dispatched", arguments: ["AccountId", "bool"], documentation: [" A call was dispatched from the given account. The bool signals whether it was", " successful execution or not."] }, EventMetadata { name: "Contract", arguments: ["AccountId", "Vec<u8>"], documentation: [" An event from contract of account."] }]) }, ModuleMetadata { name: "sudo", prefix: "Sudo", storage: Some([StorageFunctionMetadata { name: "Key", modifier: Default, ty: Plain("T::AccountId"), default: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], documentation: [" The `AccountId` of the sudo key."] }]), calls: Some([FunctionMetadata { name: "sudo", arguments: [FunctionArgumentMetadata { name: "proposal", ty: "Box<T::Proposal>" }], documentation: [" Authenticates the sudo key and dispatches a function call with `Root` origin.", "", " The dispatch origin for this call must be _Signed_."] }, FunctionMetadata { name: "set_key", arguments: [FunctionArgumentMetadata { name: "new", ty: "<T::Lookup as StaticLookup>::Source" }], documentation: [" Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.", "", " The dispatch origin for this call must be _Signed_."] }]), event: Some([EventMetadata { name: "Sudid", arguments: ["bool"], documentation: [" A sudo just took place."] }, EventMetadata { name: "KeyChanged", arguments: ["AccountId"], documentation: [" The sudoer just switched identity; the old key is supplied."] }]) }] })))
```